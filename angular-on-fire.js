// Generated by LiveScript 1.2.0
(function(){
  var module, isObject, isArray, isString, isNumber, isFunction, forEach, bind, copy, noop, noopDefer, AllSpark, extendChildSnap, extendSnap, bindPromise, FirebaseOrder, QUERY_KEYS, fireFrom, fbFrom, fireEntry;
  module = angular.module, isObject = angular.isObject, isArray = angular.isArray, isString = angular.isString, isNumber = angular.isNumber, isFunction = angular.isFunction, forEach = angular.forEach, bind = angular.bind, copy = angular.copy, noop = angular.noop;
  noopDefer = {
    resolve: noop,
    reject: noop
  };
  AllSpark = ['Firebase', 'FirebaseUrl'].concat(function(Firebase, FirebaseUrl){
    return new Firebase(FirebaseUrl);
  });
  extendChildSnap = function(parent, childName, childSnap, prevKeysStore, forceTransform){
    var val, dstVal;
    forceTransform || (forceTransform = false);
    val = childSnap.val();
    dstVal = parent[childName];
    if (isArray(val)) {
      if (!isArray(dstVal)) {
        dstVal = parent[childName] = [];
      }
    } else if (isObject(val)) {
      if (!isObject(dstVal)) {
        dstVal = parent[childName] = {};
      }
    } else {
      if (forceTransform) {
        if (!isObject(dstVal)) {
          dstVal = parent[childName] = {};
        }
        dstVal.$value = val;
      } else {
        dstVal = null;
        parent[childName] = val;
      }
    }
    if (dstVal) {
      return extendSnap(dstVal, childSnap, prevKeysStore);
    }
  };
  extendSnap = function(dst, snap, prevKeysStore){
    var newKeys, $$prevKeys, i$, len$, prevKey;
    newKeys = {};
    $$prevKeys = prevKeysStore.$$prevKeys || [];
    snap.forEach(function(childSnap){
      var key;
      key = childSnap.name();
      newKeys[key] = key;
      extendChildSnap(dst, key, childSnap, prevKeysStore[key] || (prevKeysStore[key] = {}));
    });
    for (i$ = 0, len$ = $$prevKeys.length; i$ < len$; ++i$) {
      prevKey = $$prevKeys[i$];
      if (!newKeys[prevKey]) {
        delete dst[prevKey];
      }
    }
    return prevKeysStore.$$prevKeys = Object.keys(newKeys);
  };
  bindPromise = function(target, promise){
    target.then = function(){
      promise = promise.then.apply(promise, arguments);
      return target;
    };
    target.always = function(){
      promise = promise.always.apply(promise, arguments);
      return target;
    };
    return target;
  };
  FirebaseOrder = [
    function(it){
      var that;
      that = it.$priority;
      if (that == null) {
        return 0;
      } else if (isNumber(that)) {
        return 1;
      } else if (isString(that)) {
        return 2;
      }
    }, function(it){
      var that;
      if (that = it.$priority) {
        return that;
      } else {
        return Infinity;
      }
    }, function(it){
      return it.$id;
    }
  ];
  QUERY_KEYS = ['startAt', 'endAt', 'limit'];
  fireFrom = ['$q', '$rootScope', '$timeout', 'Firebase', 'AllSpark'].concat(function($q, $rootScope, $timeout, Firebase, AllSpark){
    var promise, setDirty, digestCount, startTime, ServerValue, TYPE_MISMATCH_ERROR;
    promise = void 8;
    setDirty = function(){
      if (promise) {
        return;
      }
      promise = $timeout(function(){
        promise = void 8;
      });
    };
    digestCount = 0;
    startTime = Date.now();
    $rootScope.$watch(function(){
      if (promise && $timeout.cancel(promise)) {
        promise = void 8;
      }
    });
    ServerValue = clone$(Firebase.ServerValue);
    TYPE_MISMATCH_ERROR = function(){
      throw new TypeError('Mismatch');
    };
    return function(path, value){
      var queries, ref$, toCollection, offEvents, tmp, resolveWhenDestroyed, fireFrom, resolveWhenValue, prevKeysStore, query, ref, onValue, onEvents, context, key, val;
      if (!isObject(value)) {
        throw new TypeError("Require object");
      }
      if (isObject(path)) {
        queries = path;
        path = (ref$ = queries.path, delete queries.path, ref$);
        toCollection = (ref$ = queries.toCollection, delete queries.toCollection, ref$);
        if (toCollection && !isArray(value)) {
          throw new TypeError("Require array");
        }
      }
      queries || (queries = {});
      toCollection || (toCollection = false);
      offEvents = function(){
        forEach(['child_added', 'child_removed', 'child_changed'], function(it){
          ref.off(it);
        });
      };
      tmp = $q.defer();
      resolveWhenDestroyed = tmp.resolve;
      tmp.promise.then(offEvents);
      fireFrom = {
        ServerValue: ServerValue,
        $resolved: false,
        resolve: resolveWhenDestroyed
      };
      tmp = $q.defer();
      resolveWhenValue = function(it){
        tmp.resolve(it);
        fireFrom.$resolved = true;
        return it;
      };
      bindPromise(fireFrom, tmp.promise);
      prevKeysStore = {};
      query = null;
      ref = AllSpark.child(path);
      onValue = function(snap){
        var cache, that, index, prevId;
        if (toCollection) {
          cache = {};
          while (that = value.pop()) {
            cache[that.$id] = that;
          }
          index = -1;
          prevId = null;
          snap.forEach(function(childSnap){
            var name, ref$;
            index = index + 1;
            name = childSnap.name();
            value[index] = cache[name];
            extendChildSnap(value, index, childSnap, prevKeysStore[name] || (prevKeysStore[name] = {}), true);
            ref$ = value[index];
            ref$.$id = childSnap.name();
            ref$.$index = index;
            ref$.$priority = childSnap.getPriority();
            prevId = name;
          });
        } else {
          extendSnap(value, snap, prevKeysStore);
        }
        if (resolveWhenValue) {
          resolveWhenValue(value);
          resolveWhenValue = void 8;
        }
        setDirty();
      };
      onEvents = function(){
        if (query || toCollection) {
          return context().on('value', onValue);
        }
        ref.on('value', noop);
        ref.once('value', onValue);
        ref.on('child_added', function(childSnap, prevId){
          value[childSnap.name()] = childSnap.val();
          setDirty();
        });
        ref.on('child_removed', function(childSnap){
          delete value[childSnap.name()];
          setDirty();
        });
        ref.on('child_changed', function(childSnap){
          var name;
          name = childSnap.name();
          extendChildSnap(value, name, childSnap, prevKeysStore[name] || (prevKeysStore[name] = {}));
          setDirty();
        });
        ref.on('child_moved', noop);
      };
      context = function(){
        return query || ref;
      };
      forEach(QUERY_KEYS, function(name){
        var ref$;
        if (isArray(queries[name])) {
          query = (ref$ = context())[name].apply(ref$, queries[name]);
        }
        fireFrom[name] = function(){
          var ref$, resolve, promise;
          fireFrom.$resolved = false;
          offEvents();
          query = (ref$ = context())[name].apply(ref$, arguments);
          if (!resolveWhenValue) {
            ref$ = $q.defer(), resolve = ref$.resolve, promise = ref$.promise;
            fireFrom.then(function(){
              return promise;
            });
            resolveWhenValue = function(it){
              resolve(it);
              fireFrom.$resolved = true;
              return it;
            };
          }
          onEvents();
          return fireFrom;
        };
      });
      onEvents();
      for (key in ref) {
        val = ref[key];
        if (isFunction(val) && !in$(key, QUERY_KEYS)) {
          fireFrom[key] = bind(ref, val);
        }
      }
      return fireFrom;
    };
  });
  fbFrom = ['$parse', '$interpolate', 'fireFrom'].concat(function($parse, $interpolate, fireFrom){
    var expMatcher, rootAtPathMatcher, evalMatcher, NOOP_REF;
    expMatcher = /^\s*(\S+)\s+(in\s+(\S+)\s+)?from\s+'(.+)'$/;
    rootAtPathMatcher = /\s+(at\s+(\S*)\s*)?$/;
    evalMatcher = /\{\{([^\{,\}]+)\}\}/g;
    NOOP_REF = {};
    forEach(QUERY_KEYS, function(key){
      NOOP_REF[key] = noop;
    });
    return {
      restrict: 'A',
      scope: false,
      priority: 101,
      link: function(scope, iElement, iAttrs){
        var result, valGetter, refSetter, pathString, pathResult, rootString, _, rootKey, pathEvals, ref, offDestroyAndResolve, getValue;
        result = iAttrs.fbFrom.match(expMatcher);
        if (!result) {
          throw new Error("fbFrom should be the form ...");
        }
        valGetter = $parse(result[1]);
        refSetter = $parse(result[3]).assign || noop;
        pathString = result[4];
        pathResult = pathString.match(rootAtPathMatcher) || [];
        if (pathResult.length > 2) {
          rootString = pathResult[0], _ = pathResult[1], rootKey = pathResult[2];
          pathString = pathString.replace(rootString, '');
        }
        pathEvals = pathString.match(evalMatcher) || [];
        forEach(pathEvals, function(pathEval, index){
          scope.$watch($interpolate(pathEval), function(it){
            pathEvals[index] = it;
          });
        });
        forEach(QUERY_KEYS, function(key){
          if (!iAttrs[key]) {
            return;
          }
          scope.$watchCollection(iAttrs[key], function(it){
            ref[key].apply(ref, it);
          });
        });
        ref = NOOP_REF;
        offDestroyAndResolve = noop;
        getValue = function(path){
          var value;
          value = {};
          if (iAttrs.fbToCollection) {
            path.toCollection = true;
            value = [];
          }
          return value;
        };
        iAttrs.$observe('fbFrom', function(fbFrom){
          var path, value, prevResolve, ref$, offDestroy;
          offDestroyAndResolve();
          if (!pathEvals.every(function(it){
            return it;
          })) {
            if (ref !== NOOP_REF) {
              ref = NOOP_REF;
              refSetter(scope, ref);
              valGetter.assign(scope, getValue({}));
            }
            return;
          }
          path = {
            path: fbFrom.match(expMatcher)[4].split(rootString)[0]
          };
          forEach(QUERY_KEYS, function(it){
            var that;
            if (that = iAttrs[it]) {
              path[it] = $parse(that)(scope);
            }
          });
          value = valGetter(scope) || getValue(path);
          ref = fireFrom(path, value);
          prevResolve = (ref$ = ref.resolve, delete ref.resolve, ref$);
          offDestroy = scope.$on('$destroy', prevResolve);
          offDestroyAndResolve = function(){
            offDestroy() && prevResolve();
          };
          refSetter(scope, ref);
          ref.then(function(it){
            valGetter.assign(scope, it);
            return it;
          });
        });
      }
    };
  });
  fireEntry = ['$q', '$timeout', 'FirebaseSimpleLogin', 'AllSpark'].concat(function($q, $timeout, FirebaseSimpleLogin, AllSpark){
    return function(authReference){
      var ref$, resolve, reject, promise, ref, tmp, target, key, val;
      ref$ = $q.defer(), resolve = ref$.resolve, reject = ref$.reject, promise = ref$.promise;
      ref = new FirebaseSimpleLogin(AllSpark, function(error, auth){
        if (error) {
          return reject(error);
        }
        copy(auth || {}, authReference);
        $timeout(function(){
          resolve(authReference);
          resolve = noop;
        });
      });
      tmp = $q.defer();
      tmp.promise.then(function(){
        console.log("fireEntry's scope destroyed!!");
      });
      target = bindPromise({
        resolve: tmp.resolve
      }, promise);
      for (key in ref) {
        val = ref[key];
        if (isFunction(val)) {
          target[key] = bind(ref, val);
        }
      }
      return target;
    };
  });
  module('angular-on-fire', []).constant({
    FirebaseUrl: 'https://pleaseenteryourappnamehere.firebaseIO.com/'
  }).value({
    Firebase: Firebase,
    FirebaseSimpleLogin: FirebaseSimpleLogin,
    FirebaseOrder: FirebaseOrder
  }).factory({
    AllSpark: AllSpark,
    fireFrom: fireFrom,
    fireEntry: fireEntry
  }).directive({
    fbFrom: fbFrom
  });
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
