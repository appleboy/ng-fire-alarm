// Generated by LiveScript 1.2.0
(function(){
  var module, isObject, isArray, isString, isNumber, isFunction, forEach, bind, copy, extend, noop, toJson, noopDefer, noopRef, AllSpark, FirebaseOrder, fireEntry, QUERY_KEYS, evalMatcher, SourceSpark, SourceSparkFactory, fbSpark;
  module = angular.module, isObject = angular.isObject, isArray = angular.isArray, isString = angular.isString, isNumber = angular.isNumber, isFunction = angular.isFunction, forEach = angular.forEach, bind = angular.bind, copy = angular.copy, extend = angular.extend, noop = angular.noop, toJson = angular.toJson;
  noopDefer = {
    resolve: noop,
    reject: noop
  };
  noopRef = {
    off: noop
  };
  AllSpark = ['Firebase', 'FirebaseUrl'].concat(function(Firebase, FirebaseUrl){
    return new Firebase(FirebaseUrl);
  });
  FirebaseOrder = [
    function(it){
      var that;
      that = it.$priority;
      if (that == null) {
        return 0;
      } else if (isNumber(that)) {
        return 1;
      } else if (isString(that)) {
        return 2;
      }
    }, function(it){
      var that;
      if (that = it.$priority) {
        return that;
      } else {
        return Infinity;
      }
    }, function(it){
      return it.$id;
    }
  ];
  fireEntry = ['$q', '$timeout', 'FirebaseSimpleLogin', 'AllSpark'].concat(function($q, $timeout, FirebaseSimpleLogin, AllSpark){
    return function(authReference){
      var ref$, resolve, reject, promise, ref, tmp, target, key, val;
      ref$ = $q.defer(), resolve = ref$.resolve, reject = ref$.reject, promise = ref$.promise;
      ref = new FirebaseSimpleLogin(AllSpark, function(error, auth){
        if (error) {
          return reject(error);
        }
        copy(auth || {}, authReference);
        $timeout(function(){
          resolve(authReference);
          resolve = noop;
        });
      });
      tmp = $q.defer();
      tmp.promise.then(function(){
        console.log("fireEntry's scope destroyed!!");
      });
      target = {
        resolve: tmp.resolve,
        then: function(){
          promise = promise.then.apply(promise, arguments);
        }
      };
      for (key in ref) {
        val = ref[key];
        if (isFunction(val)) {
          target[key] = bind(ref, val);
        }
      }
      return target;
    };
  });
  QUERY_KEYS = ['startAt', 'endAt', 'limit'];
  evalMatcher = /\{\{\s*(\S*)\s*\}\}/g;
  SourceSpark = (function(){
    SourceSpark.displayName = 'SourceSpark';
    var waitForPaths, getConfig, getRef, trimValSize, injectProps, snapToVal, promise, queue, timeoutedFn, delayMillis, prototype = SourceSpark.prototype, constructor = SourceSpark;
    function SourceSpark(){
      this.nextHandler = [];
      this.config = {};
    }
    waitForPaths = function(config, childSnap, childIndex, readValue){
      var pathEvals, res$, that, callNext, this$ = this;
      res$ = [];
      while (that = evalMatcher.exec(config.path)) {
        res$.push(that);
      }
      pathEvals = res$;
      callNext = function(value, pathIndex){
        var paths, i$, to$, i;
        pathEvals[pathIndex] = value;
        if (!pathEvals.every(function(it){
          return !isArray(it) && it;
        })) {
          return;
        }
        paths = config.path.split(evalMatcher);
        for (i$ = 1, to$ = paths.length; i$ < to$; i$ += 2) {
          i = i$;
          paths[i] = pathEvals[Math.floor(i / 2)];
        }
        readValue(extend({}, config, {
          path: paths.join('')
        }), childIndex);
      };
      if (pathEvals.length === 0) {
        readValue(config, childIndex);
        return this;
      }
      pathEvals.forEach(function(array, pathIndex){
        switch (array[1]) {
        case '$id':
          return callNext(childSnap.name(), pathIndex);
        default:
          return this._requireScope().$watch(constructor.$interpolate(array[0]), function(it){
            if (!it) {
              return;
            }
            callNext(it, pathIndex);
          });
        }
      }, this);
      return this;
    };
    getConfig = function(method, config){
      if (isObject(config)) {
        return config;
      } else if (isString(config)) {
        return {
          path: config
        };
      } else {
        throw new Error(method + " require string or object but got " + config);
      }
    };
    getRef = function(AllSpark, config){
      var ref;
      ref = AllSpark.child(config.path);
      QUERY_KEYS.filter(function(it){
        return config[it];
      }).forEach(function(name){
        return ref = ref[name].apply(ref, config[name]);
      });
      return ref;
    };
    trimValSize = function(val, targetSize){
      var i;
      targetSize || (targetSize = 0);
      if (val.length >= targetSize) {
        val.splice(targetSize, val.lengthTargetSize);
      } else {
        val.push.apply(val, (function(){
          var i$, to$, results$ = [];
          for (i$ = val.length, to$ = targetSize; i$ < to$; ++i$) {
            i = i$;
            results$.push(void 8);
          }
          return results$;
        }()));
      }
      if (val.length !== targetSize) {
        throw new Error("Mismatch " + val.length + ", " + targetSize);
      }
      targetSize;
    };
    prototype._requireScope = function(){
      var that;
      if (that = this.scope) {
        return that;
      } else {
        throw new Error("Scope!!");
      }
    };
    prototype.get = function(config){
      this.config = getConfig('get', config);
      return this;
    };
    prototype.map = function(config){
      var handlerIndex;
      config = getConfig('map', config);
      handlerIndex = this.nextHandler.length + 1;
      this.nextHandler.push(function(it){
        var refsMap, val, numChildren, index, this$ = this;
        refsMap = {};
        val = [];
        numChildren = trimValSize(val, (typeof it.numChildren === 'function' ? it.numChildren() : void 8) || it.length);
        index = -1;
        it.forEach(function(it){
          var name;
          index = index + 1;
          name = it.name();
          refsMap[name] || (refsMap[name] = noopRef);
          waitForPaths.call(this$, config, it, index, function(config, childIndex){
            refsMap[name].off();
            refsMap[name] = getRef(constructor.AllSpark, config);
            refsMap[name].on('value', function(it){
              val[childIndex] = it;
              if (val.every(function(it){
                return it;
              })) {
                this.nextHandler[handlerIndex].call(this, val);
              }
            }, noop, this$);
          });
        });
      });
      return this;
    };
    prototype.reduce = function(){
      var handlerIndex;
      handlerIndex = this.nextHandler.length + 1;
      this.nextHandler.push(function(it){
        var val;
        val = [];
        it.forEach(function(it){
          it.forEach(function(it){
            val.push(it);
          });
        });
        this.nextHandler[handlerIndex].call(this, val);
      });
      return this;
    };
    prototype.clone = function(config){
      var cloned;
      cloned = new SourceSpark();
      copy(this.nextHandler, cloned.nextHandler);
      copy(this.config, cloned.config);
      if (isObject(config)) {
        extend(cloned.config, config);
      }
      return cloned;
    };
    prototype._execute = function(){
      var ref, this$ = this;
      ref = noopRef;
      return waitForPaths.call(this, this.config, null, 0, function(config){
        ref.off();
        ref = getRef(constructor.AllSpark, config);
        ref.on('value', function(it){
          this.nextHandler[0].call(this, it);
        }, noop, this$);
      });
    };
    injectProps = function(it){
      var that;
      if (that = typeof it.val === 'function' ? it.val() : void 8) {
        if (!isObject(that)) {
          that = {
            $value: that
          };
        }
        that.$id = it.name();
        that.$priority = it.getPriority();
      } else {
        that = {};
      }
      return [that, it.ref()];
    };
    snapToVal = function(it, toCollection){
      var vals, refs;
      if (toCollection || isArray(it)) {
        vals = [];
        refs = [];
        it.forEach(function(it){
          var ref$, val, ref;
          ref$ = injectProps(it), val = ref$[0], ref = ref$[1];
          vals.push(val);
          refs.push(ref);
        });
        return [vals, refs];
      } else {
        return injectProps(it);
      }
    };
    prototype.defer = function(toCollection){
      var ref$, resolve, promise;
      ref$ = constructor.$q.defer(), resolve = ref$.resolve, promise = ref$.promise;
      this.nextHandler.push(function(it){
        resolve(
        snapToVal(it, toCollection)[0]);
      });
      this._execute();
      return promise;
    };
    promise = void 8;
    queue = [];
    timeoutedFn = function(){
      var that;
      while (that = queue.shift()) {
        that();
      }
      promise = void 8;
    };
    delayMillis = 300;
    prototype._setScope = function(scope, valueSetter, refSetter, toCollection){
      if (this.scope) {
        return;
      }
      this.scope = scope;
      this.nextHandler.push(function(it){
        var ref$, vals, refs, updateFn;
        ref$ = snapToVal(it, toCollection), vals = ref$[0], refs = ref$[1];
        updateFn = function(){
          valueSetter(scope, vals);
          refSetter(scope, refs);
        };
        if (scope.$root.$$phase) {
          queue.push(updateFn);
          if (!promise) {
            constructor.$timeout(timeoutedFn, delayMillis);
          }
        } else {
          scope.$apply(updateFn);
        }
      });
      this._execute();
    };
    return SourceSpark;
  }());
  SourceSparkFactory = ['$q', '$timeout', '$interpolate', 'AllSpark'].concat(function($q, $timeout, $interpolate, AllSpark){
    return SourceSpark.$q = $q, SourceSpark.$timeout = $timeout, SourceSpark.$interpolate = $interpolate, SourceSpark.AllSpark = AllSpark, SourceSpark;
  });
  fbSpark = ['$parse', 'SourceSpark'].concat(function($parse, SourceSpark){
    var expMatcher;
    expMatcher = /\s*(\S+)(?:\s+from\s+(\S+))?\s+in\s+([^;\s]+)\s*;*/g;
    return {
      restrict: 'A',
      link: function(scope, iElement, iAttrs){
        var validKeys, config, updateSparks, sparks, res$, that;
        validKeys = QUERY_KEYS.filter(function(it){
          return iAttrs[it];
        });
        config = {};
        validKeys.forEach(function(it){
          scope.$watchCollection(iAttrs[it], function(arg$){
            config[it] = arg$;
            updateSparks();
          });
        });
        updateSparks = function(){
          if (!validKeys.every(function(it){
            return isArray(config[it]);
          })) {
            return;
          }
          sparks.forEach(function(it){
            var spark;
            spark = it[2](scope);
            if (!spark) {
              return;
            }
            spark.clone(config)._setScope(scope, it[0].assign, it[1].assign || noop, iAttrs.fbToCollection);
          });
        };
        res$ = [];
        while (that = expMatcher.exec(iAttrs.fbSpark)) {
          res$.push(that.slice(1, 4).map($parse));
        }
        sparks = res$;
        if (!validKeys.length) {
          updateSparks();
        }
      }
    };
  });
  module('angular-on-fire', []).constant({
    FirebaseUrl: 'https://pleaseenteryourappnamehere.firebaseIO.com/'
  }).value({
    Firebase: Firebase,
    FirebaseSimpleLogin: FirebaseSimpleLogin,
    FirebaseOrder: FirebaseOrder
  }).factory({
    AllSpark: AllSpark,
    fireEntry: fireEntry,
    SourceSpark: SourceSparkFactory
  }).directive({
    fbSpark: fbSpark
  });
}).call(this);
